// SPDX-License-Identifier: MIT
pragma solidity ^0.7.5;

import "./IERC20.sol";
import "./ILendingPool.sol";
import "./OffsToken.sol";
import "./SafeMath.sol";

contract Offseth {
	ILendingPool pool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9); //Lending pool contract address
	IERC20 dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F); 	//Dai contract address
	IERC20 aDai = IERC20(0x028171bCA77440897B824Ca71D1c56caC55b68A3); 	//aDai contract address

	using SafeMath for uint256;
	
	uint256 daiPerToken = 15; 			//Number of Dais per each OFFS token
	OffsToken public offsTokenContract; //OFFS token contract

	struct Stacked {
		uint256 amount;
		uint256 current_reward;
		uint256 date_deposited;
		uint256 total_earned;
		uint256 last_earned_date;
		bool isMember;
	}

	address public owner;
	uint256 public totalDeposit;
	uint256 public startRound;
	uint256 public endRound;
	uint256 public roundNum;
	uint256 public totalEarned;
	uint256 public earned;

	mapping(address => Stacked) public stakes;
	address[] public userList;

	// Events
    event Deposit(address indexed _user, uint256 _amount);
    event Withdraw(address indexed _user, uint256 _amount);
    event TokenSend(address indexed _user, uint256 _amount);
    event Sell(address indexed _user, uint256 _amount);


    /**
     * Constructor function
     *
     * Initializes contract with owner and starts the first round
     */
	constructor(OffsToken _offsTokenContract) public {
		owner = msg.sender;
		offsTokenContract = _offsTokenContract;

		//Initiate the params
		totalDeposit = 0;
		totalEarned = 0;
		roundNum = 1;
		startRound = block.timestamp;
		endRound = block.timestamp + 30 days;
	}


	/**
	 * Start the next round
	 *
	 * Allows the owner to start the next round
	 * Automatically distribute the rewards to all participants
	 */
	function executeStartRound() public {
		require(msg.sender == owner, "Only the owner");
		require(block.timestamp > endRound, "Round not finished yet");

		calculateEarned();
		distributeRewards();

		roundNum += 1;
		startRound = block.timestamp;
		endRound = block.timestamp + 30 days;
	}


	/**
	 * Allows users to deposit their Dai
	 * 
	 * First updates the user rewards
	 * Then transfer to the pool on behalf the user
	 */
	function deposit() public payable {
		calculateEarned();
		calculateRewards(msg.sender);
		
		// Update the stakes info for user
		stakes[msg.sender].amount = stakes[msg.sender].amount.add(msg.value);
		stakes[msg.sender].date_deposited = block.timestamp;
		stakes[msg.sender].isMember = true;

		// Add the user to the userList
		userList.push(msg.sender);

		// Update the totalDiposit of the contract
		totalDeposit = totalDeposit.add(msg.value);

		// Aprove & Deposit Dai to Aave Pool
		dai.approve(address(pool), msg.value);
		pool.deposit(address(dai), msg.value, address(this), 0);

		emit Deposit(msg.sender, msg.value);
	}


	/**
	 * Allows users to withdraw their Dai
	 * 
	 * First updates the user rewards
	 * Then transfer to the user the desired amount
	 */
	function withdraw(uint256 _amount) public {
		require(isMember(msg.sender), "No member"); //Is member
		require(_amount <= stakes[msg.sender].amount, "Not enoght funds"); //Has enought funds

		calculateEarned();
		calculateRewards(msg.sender);

		// Update the stakes info for user
		stakes[msg.sender].amount = stakes[msg.sender].amount.sub(_amount);
		stakes[msg.sender].date_deposited = block.timestamp;

		// Update the totalDeposit for the contract
		totalDeposit = totalDeposit.sub(_amount);
		
		// Approve & Withdraw aDai from Aave Pool
		aDai.approve(address(pool), _amount);
		pool.withdraw(address(dai), _amount, msg.sender);

		emit Withdraw(msg.sender, _amount);
	}


	/**
	 * Allow user to withdraw their Offs rewards
	 * 
	 * Calculate the num of Offs tokens (based on user rewards and daiPerToken)
	 * and transfer the amount to the user.
	 * 
	 * @param _amount The amount of the rewards to withdraw
	 */
	function withdrawRewards(uint256 _amount) public {
		require(isMember(msg.sender), "No member"); //Is member
		require(_amount <= stakes[msg.sender].current_reward, "Not enought rewards"); //Has enought funds

		stakes[msg.sender].current_reward = stakes[msg.sender].current_reward.sub(_amount);
		uint256 _numberOfTokens = _amount.div(daiPerToken);

		require(offsTokenContract.balanceOf(address(this)) >= _numberOfTokens, "Not enought Offs Tokens");
		offsTokenContract.transfer(msg.sender, _numberOfTokens);

		emit TokenSend(msg.sender, _numberOfTokens);
	}


	/**
	 * Calculates the number of Dai generated by the AAVE pool interest
	 * that the user generated in this round and accumulates to the total
	 *
	 * @param _user The address of the user to calculate the rewards
	 */
	function calculateRewards(address _user) private {
		require(isMember(_user), "Not member");

		// Get timestamp user deposited
		uint256 _start = stakes[_user].date_deposited;

		// If it was before the round start, set to round start
		if(_start < startRound){
			_start = startRound;
		}

		// If user already earned this round, get that timestamp
		if(stakes[_user].last_earned_date > _start){
			_start = stakes[_user].last_earned_date;
		}

		// Get the endRound or if the round is not finished, the block.timestamp timestamp
		uint256 _end = endRound;
		if(block.timestamp < endRound){
			_end = block.timestamp;
		}

		// Days that the user has been in the round
		uint256 _userDays = ( _end.sub(_start) ).div(86400); // 60*60*24 sec to days

		// The total num of days of the round
		uint256 _totalDays = ( endRound.sub(startRound) ).div(86400);

		// Set the reward based on percentage of the user deposit and the num of days of deposit
		uint256 _reward = ( (earned.div(_totalDays)).mul(_userDays) ).mul( stakes[_user].amount.div(totalDeposit) );
		require (_reward <= totalEarned, "Reward could not be greater than totalEarned");

		// Update rewards stats and user stats
		stakes[_user].last_earned_date = block.timestamp;
		totalEarned = totalEarned.add(_reward);
		stakes[_user].current_reward = stakes[_user].current_reward.add(_reward);
		stakes[_user].total_earned = stakes[_user].total_earned.add(_reward);
	}


	/**
	 * Distributes the rewards generated by each user in this round
	 * Called by the owner when a round ends
	 * Moves all the generated Dai to the DAO contract to buy CO2 Tokens
	 */
	function distributeRewards() private {
		require(msg.sender == owner, "Only Owner");

		// Foreach user, distribute rewards
		for(uint i = 0; i<userList.length; i++) {
			calculateRewards(userList[i]);
		}

		// Move all the earnings to the DAO to purchase CO2 offsets with it
		calculateEarned();
		//moveBenefitsToDAO(); << TODO
	}


	/**
	 * Calculate the diference between the users deposits and the AAVE pool
	 * (the pool earnings in aDai)
	 */
	function calculateEarned() private {
        uint256 _totalBalance = aDai.balanceOf(address(this));
        earned = (_totalBalance.sub(totalDeposit));
	}


	/**
     * Buy Tokens function
     *
     * Allows users to buy tokens
     */
    function buyTokens(uint256 _numberOfTokens) public payable {
        require(msg.value == _numberOfTokens.mul(daiPerToken));
        require(offsTokenContract.balanceOf(address(this)) >= _numberOfTokens);
        require(offsTokenContract.transfer(msg.sender, _numberOfTokens));

        emit Sell(msg.sender, _numberOfTokens);
    }


	/**
	 * Returns if a user is member of the contract
	 *
	 * @param _addr The address of the user
	 */
	function isMember(address _addr) public view returns(bool) {
		return stakes[_addr].isMember;
	}


	/**
	 * Allows the owner to change the num of tokens per Dai
	 */
	function updateTokensPerDay(uint256 _newDaiPerToken) public {
		require(msg.sender == owner, "Only Owner");
		daiPerToken = _newDaiPerToken;
	}

}